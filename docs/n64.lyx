#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme palatino
\graphics default
\paperfontsize 12
\spacing single 
\papersize letterpaper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Embedded MIPS Development with the Nintendo 64
\layout Author

Ryan Underwood
\layout Abstract

Using Nintendo's 64-bit console, we explore the intricacies and design decisions
 involved in developing software for a console or embedded platform.
 
\series bold 
This is a work in progress!
\layout Section

Introduction
\layout Paragraph

Embedded development, while drastically simplified compared to systems programmi
ng for a general purpose platform, presents many challenges to attain a
 superior product at minimal cost.
 The first set of challenges we can identify are purely physical.
 Obviously, the speed of the CPU and the size of memory are the two main
 decisions that impact the cost per unit.
 Also necessary to consider is what user interface is desired, and the appropria
te I/O hardware to accomodate each aspect of the interface.
 Size must be considered, not only in terms of material cost; who wants
 to lug around a bulky digital music player? Power consumption is critical;
 it presents a three-pronged blade to threaten effective platform design.
 The first issue is simply the rate at which the system consumes power.
 This is a problem especially for battery-powered devices, but extends as
 a problem of scalability too; greater power consumption simply means greater
 operating cost to the end user and thus a lesser value assigned to the
 product.
 Power consumption is determined by the components selected for the platform,
 as well as how software chooses to utilize those components.
 The second issue is the heat that is dissipated by the switching of silicon
 gates.
 Excessive heat generation produces undesirable traits for the user, and
 can also lead to premature component failures.
 Usually, power consumption and heat dissipation of a system are strongly
 linked, and frequently result from a hardware design strategy that is excessive
 in nature.
 The last issue is that of reliability.
 Designs which employ a high rate of power consumption must have safety
 features such as filters scattered throughout the system to prevent erroneous
 behavior under load, and require higher or tighter component tolerances
 in areas such as the power supply.
 All this leads to extra design time, more potential sources of design error,
 and extra unit cost.
\layout Paragraph

Among other factors, the number of components and their complexity affect
 size and power consumption the most.
 Therefore, the hardware designer is faced with a difficult tradeoff.
 Essentially, he must select which features of a general purpose computing
 platform must be omitted in his embedded platform in order to reduce costs,
 while allowing the features that will provide the user with the most value
 to remain.
 What makes this decision even more difficult is that knowing which features
 will provide the most value requires knowledge of how software designers
 will make use of the platform.
 Frequently, the wrong features are cut and less important features remain,
 incurring unnecessary cost on the manufacturer and thwarting attempts at
 elegant software design.
\layout Paragraph

The focus of this text is on software development where the hardware platform
 is a given.
 Targeting a fixed and known hardware platform fits well with development
 for set-top boxes or game consoles, but also with the rising popularity
 of single-board computers and System-On-a-Chip (SOC) solutions.
 In this paradigm, the hardware is mass produced so that it may be sold
 at a very low cost, and individual providers develop the software to run
 on the mass produced platform.
 The hardware/software combination together completes the product that is
 to be shipped to end users.
\layout Paragraph

Our focus is on development for a game console, the Nintendo 64 (heretoafter
 referred to as Ultra 64 or N64), which had a multi-year mass market lifespan.
 Consequently, the install base is very large and consists of primarily
 users who purchased the console to be able to use game software designed
 for it.
 The knowledge we gain in developing a software platform for this console
 can be extended to embedded development in general; the only difference
 is that in an embedded product, the platform and its software are designed
 to be inseparable.
 If the N64 were an embedded platform, it would have shipped with the program
 cartridge moulded to the console.
\layout Section

Taking Stock of the Hardware
\layout Paragraph

As software designers, we will be working intimately with our chosen hardware
 platform.
 Therefore, it is essential to know with as much precision as possible what
 the details of our hardware architecture are.
 Sometimes hardware manufacturers or licensed third parties offer complete
 SDKs (Software Development Kits) for their platforms that ease the bootstrappin
g of a project; usually an experienced C programmer will be able to make
 use of a SDK to drastically cut down time-to-market.
 However, the SDK usually contains proprietary information obtained or developed
 at cost to the platform designer, which manifests itself to the software
 developer as a per-unit licensing fee or the unavailability of source code.
 (See Section 3 for more information on SDKs).
 For this discussion, we will focus on developing software solutions without
 a third-party SDK, and on developing our own SDK to use in-house or to
 license to third parties.
\layout Paragraph

The information we need to know about our platform boils down to three categorie
s:
\layout Enumerate

How to program the processor(s)
\layout Enumerate

How to program peripherals
\layout Enumerate

How to execute our code on the target
\layout Paragraph

This information can be gleaned (rarely) from marketing materials, or more
 usually a designer's handbook.
 In a limited fashion, it can also be derived from observation or from reverse
 engineering.
\layout Paragraph

The N64's hardware features are as follows:
\layout Itemize

MIPS R4300i RISC 64-bit embedded processor, 93.75 MHz
\layout Itemize

Reality CoProcessor (RCP), 62.5 MHz
\layout Itemize

4MB Rambus RDRAM (8MB with memory expansion)
\layout Itemize

4 peripheral ports
\layout Itemize

Cartridge/system bus interface
\layout Standard

<FIXME block diagram>
\layout Paragraph

MIPS provides a public specification for the MIPS IV instruction set as
 well as the R4300i processor specifically.
 Therefore, programming this processor should be no problem, assuming no
 customization has been made to it.
\layout Paragraph

The rest of the system is documented only privately, in the Nintendo SDK
 HTML manuals and 'man' pages.
 These are available to SDK licensees only.
 Furthermore, these documents typically only cover the Nintendo SDK operating
 system interfaces, and do not go into much detail about the underlying
 software<->hardware interface.
 Information about the rest of the system has been derived by members of
 the 
\begin_inset LatexCommand \url[Dextrose]{http://www.dextrose.com}

\end_inset 

 group and message board, by N64 emulator authors, by many unnamed and defunct
 groups around the globe, and by commercial interests who develop unofficial
 N64 development platforms to be sold at a much lower cost than the official
 ones.
 Through the efforts of these disparate (and only occasionally cooperating)
 groups, unofficial programming information for nearly all of the N64's
 peripherals, its coprocessor, and its memory/register map have been produced.
 Nintendo is unable to claim any intellectual property rights on this independen
tly derived information, so we use it freely in this document.
 We use symbolic constant names compatible with the official SDK, so that
 individuals already familiar with the SDK can more easily follow along.
\layout Standard

FIXME: note Sega vs Accolade, Nintendo v Tengen court cases regarding hardware
 lock-outs.
\layout Subsection

Programming the N64 CPU
\layout Paragraph

The NEC R4300i implements the MIPS III instruction set.
 The CPU runs at 93.75 MHz PClock (MasterClock*1.5) and can be switched at
 runtime between 32-bit and 64-bit addressing.
 It can execute one instruction per clock cycle and has a 5-stage pipeline.
 It has a 16KB instruction cache and a 8KB write-back data cache (both non-parit
y).
 At this clock speed, it attains 125 MIPS and a score of 60/45 on SPECint/fp92.
 It has fixed-width instructions and clearly defined coprocessor interfaces.
 The N64 CPU is configured to run in big-endian mode.
\layout Subsubsection

Addressing and Cacheability
\layout Paragraph

The CPU has three modes of execution according to the R4300 datasheet: kernel,
 supervisor, and user mode.
 Since we are in complete control of the machine, we will exclusively be
 operating in kernel mode.
 (If we were writing a general purpose operating system, we would implement
 the operating system in kernel mode, and processes would be executed in
 user mode.
 kseg0 and kseg1 would be inaccessible in user mode.) We will also use 32-bit
 addressing instead of 64-bit; since the N64 is limited to 8 megabytes of
 system memory, 64-bit pointers gain us no benefit on this platform.
\layout Paragraph

An important effect of the mode of the processor is in determining the system's
 memory map.
 According to the R4300 datasheet, there are five regions of memory when
 in Kernel mode:
\layout Itemize

0x00000000-0x7FFFFFFF: kuseg (TLB-mapped 2G physical)
\layout Itemize

0x80000000-0x9FFFFFFF: kseg0 (direct-mapped 512MB, cached)
\layout Itemize

0xA0000000-0xBFFFFFFF: kseg1 (direct-mapped 512MB, uncached)
\layout Itemize

0xC0000000-0xDFFFFFFF: ksseg (TLB-mapped)
\layout Itemize

0xE0000000-0xFFFFFFFF: kseg3 (TLB-mapped)
\layout Paragraph

We are concerned mainly with the first three regions.
 The power-on configuration causes the physical memory of the N64 to be
 repeated in kuseg, kseg0, and kseg1.
 The access characteristics differ, however.
 The only difference we are concerned with between kuseg and kseg0 is that
 kuseg is accessed through the CPU's TLB (translation lookaside buffer).
 This can incur a performance penalty.
 Since we do not need more than a 512MB virtual address space on the N64,
 we will use kseg0 instead of kuseg under almost all conditions.
 kseg1 is useful because occasionally bypassing the CPU's cache is desirable.
 With some exceptions, usually we will use the following guidelines for
 selecting memory regions:
\layout Itemize

Use kseg0 for general programming and especially when high performance is
 required.
\layout Itemize

Use kseg1 when accessing hardware registers and external memories, and when
 writing data intended to be picked up by peripheral DMA.
\layout Paragraph

If we write to a cached region (kseg0), we must always remember to flush
 the CPU data cache before using that memory for operations in the RCP or
 other peripherals; when peripherals are programmed to perform DMA reads,
 they will always access the uncached version of the data directly from
 memory.
 Also, when a peripheral performs a DMA write to memory, we need to invalidate
 the CPU cache for that region to ensure that a subsequent CPU cache flush
 doesn't overwrite any data fetched from the peripheral.
\layout Paragraph

It is possible to disable the kseg0 caching to aid in debugging.
 See section 
\begin_inset LatexCommand \ref{sub:Programming-the-RCP}

\end_inset 

 for more information.
\layout Paragraph

Remember that if the low 29 bits of two addresses are identical, their physical
 location is identical.
 Changing the upper four bits only changes the CPU's access strategy (cached/unc
ached and TLB-mapped or direct-mapped).
 For example, the PIF-ROM can be found at two seemingly different locations
 -- 0x1FC00000 and 0xBFC00000.
 Using the knowledge we just gained, we realize that these two locations
 are actually one and the same, because the low-order 29 bits in the two
 addresses are identical.
 One difference is that accessing the PIF-ROM through 0x1FC00000 uses the
 TLB, and accessing it through 0xBFC00000 does not require any address translati
on.
 The other difference is that accessing it through 0xBFC00000 bypasses the
 CPU's data cache, whereas 0x1FC00000 is always a cached access (unless
 we have previously invalidated the CPU data cache for that address, or
 have disabled the TLB cache bit for that region).
\layout Paragraph

When describing hardware addresses, the preferred region to access whatever
 unit is being described will be given.
 Do not infer, however, that the given address is the only method of access.
 Indeed, under some circumstances, we will find ourselves forced to use
 unconventional procedure, to work around performance problems or unexpected
 hardware interactions.
 Use whatever addressing scheme is best for the particular unit of code
 under question.
\layout Subsubsection

Delay Slots
\layout Paragraph

For the highest performing code, we must observe the necessity of delay
 slots on the MIPS architecture.
 Delay slots are required by the design in order to prevent pipeline stalls.
 A delay slot is specified when:
\layout Itemize

A conditional branch is taken.
\newline 
The instruction in the delay slot is executed, unless the branch instruction
 is a 
\begin_inset Quotes eld
\end_inset 

Likely
\begin_inset Quotes erd
\end_inset 

 branch.
\layout Itemize

A register load is performed.
\newline 
If the instruction in the delay slot is dependent on the register being
 loaded, an interlock condition occurs and the processor must stall while
 its pipeline is reloaded (5 clock cycles).
 In the case of a register load with a coprocessor source, the destination
 register is not filled until after the next instruction has executed! (There
 is no interlock on coprocessor loads.)
\layout Paragraph*

Not observing the branch or load delay slots will cause a decline in performance
 or unwanted behavior.
 Not observing the coprocessor delay slots will cause unspecified behavior.
\layout Subsubsection

Exception Handling
\layout Paragraph

The MIPS reset/NMI vector is mapped at reset to 0xBFC00000 (0x1FC00000 in
 kuseg).
 As we will later see, the reset condition is always handled by an embedded
 ROM (PIF-ROM) in the N64 which manages the security lock-out chip.
 The vector can be changed later for purposes of NMI or soft-reset (generated
 by the Reset button on the console), but we can't do anything about a hard
 reset; the PIF-ROM will always be executed.
 (FIXME right?)
\layout Paragraph

The general exception vector is at 0xBFC00380 when BEV is set (see section
 
\begin_inset LatexCommand \ref{sub:Programming-the-RCP}

\end_inset 

), and can be used for all other purposes.
 When an exception condition is encountered, the address at 0xBFC00380 will
 be the target of a branch, and the machine state will be on the stack.
\layout Subsubsection

Code Generation
\layout Paragraph

Assembling MIPS instructions to binary can be performed using the GNU binutils
 package, configured for the mips or mips64 targets.
 32-bit MIPS code can be executed on the N64, but 64-bit code gives higher
 performance with calculations involving large values.
 We will later use the GNU C compiler to generate MIPS code, but it is much
 easier for now to simply build binutils (for the assembler) than to build
 a complete C/C++ toolchain.
 In addition, running a C program requires start-up code, which we have
 not developed yet, to initialize the hardware and stack pointer and to
 invoke main().
\layout Subsection


\begin_inset LatexCommand \label{sub:Programming-the-RCP}

\end_inset 

Programming the RCP Coprocessor Unit
\layout Paragraph

The RCP is implemented as a standard MIPS coprocessor (CP0 and CP1).
 Most of its interface sub-units (*I) can be accessed through memory mapped
 registers.
 It runs at 62.5 MHz (MasterClock) and is capable of 500MFlops at that speed.
 It is based on a .35 micron manufacturing process.
 It is responsible for virtual memory, exception handling, and floating
 point processing.
\layout Paragraph

The various functional subunits of the RCP can be accessed through memory-mapped
 registers.
 The available subunits are:
\layout Itemize

RSP (Reality Signal Processor)
\newline 
A custom RISC processor with vector operations.
 The N64 sends it microcode and a command list that the microcode interprets,
 to produce graphics commands for the RDP or sound output.
\layout Itemize

RDP (Reality Display Processor)
\newline 
The rasterizing engine of the N64.
 The RDP receives commands from the RSP or a memory buffer, and writes the
 generated image data to the N64's framebuffer memory.
\layout Itemize

VI (Video Interface)
\newline 
The N64's framebuffer interface.
 It displays the contents of the framebuffer on the external video display.
\layout Itemize

AI (Audio Interface)
\newline 
Plays digital audio samples via DMA.
\layout Itemize

PI (Peripheral Interface)
\newline 
Connects cartridges and external hardware units to the N64.
\layout Itemize

MI (MIPS Interface)
\newline 
A control interface for CPU-related functionality, such as masking interrupts
 or determining the source of an interrupt.
\layout Itemize

RI (RDRAM Interface)
\newline 
The RCP's interface to system memory.
\layout Itemize

SI (Serial Interface)
\newline 
Responsible for accessing devices connected to the controller ports.
\layout Subsubsection

CP0 Registers
\layout Paragraph

Here we list the CP0 registers that interest us.
 There are more, but the others deal with OS memory management (TLB), which
 we are not particularly concerned with at the moment.
\layout List
\labelwidthstring 00.00.0000

R9 (Count) Timer count register
\layout List
\labelwidthstring 00.00.0000

R11 (Compare) Timer compare value register
\layout List
\labelwidthstring 00.00.0000

R12 (SR) Status Register
\layout List
\labelwidthstring 00.00.0000

R13 (Cause) Exception Cause
\layout List
\labelwidthstring 00.00.0000

R14 (EPC) Exception Saved PC
\layout List
\labelwidthstring 00.00.0000

R16 (Config) Config Register
\layout List
\labelwidthstring 00.00.0000

R18 (WatchLo) address trap lower bits
\layout List
\labelwidthstring 00.00.0000

R19 (WatchHi) address trap upper bits
\layout List
\labelwidthstring 00.00.0000

R30 (ErrorEPC) Reset/NMI saved PC
\layout List
\labelwidthstring 00.00.0000

RP - Reduced Power - Bit 27 On
\layout Standard

FR - Floating-point Register - Bit 26 On
\layout Standard

RE - Reverse Endian - Bit 25 On
\layout Standard

BEV - Bootstrap Exception Vector - Bit 22 On
\layout Standard

SR - Is set if Soft Reset/NMI occurred - Bit 20
\layout Standard

KSU - Set to 00 for kernel mode - Bit 3-4
\layout Standard

ERL - Is set if a CPU error occurred - Bit 2
\layout Standard

EXL - Is set if an exception occurred - Bit 1
\newline 
Read the cause register to figure out what happened
\layout Standard

IE - Interrupt Enable - Bit 0 On
\layout Standard

ErrorEPC register - Reset/NMI saved PC
\layout Standard

EPC register - Exception saved PC
\layout Standard

WatchHi/WatchLo registers to trap memory accesses
\layout Standard

Config register -
\layout Standard

EC - Bit 28-30 System Clock Ratio (1:1/110 1.5:1/111 2:1/000 3:1/001) readonly
\layout Standard

BE - Bit 15 - Big Endian - 0 => LE, 1=> BE
\layout Standard

K0 - bit 0-2 - 010 => noncacheable 011=>cacheable
\layout Standard

Count register / Compare register / sets IP7 which causes
\layout Standard

interrupt if IE / write to Compare to clear
\layout Standard

Count increments at 1/2 PClock and rolls over.
\layout Subsection

Programming the RSP (Reality Signal Processor)
\layout Subsection

Programming the RDP (Reality Display Processor)
\layout Standard

4KB Texture memory (one 32x32 RGBA texture)
\layout Standard

Features:
\layout Standard

Alpha Transparency (8-bit)
\layout Standard

Anti-Aliasing
\layout Standard

Bilinear/Trilinear Filtering/Interpolation (and Point Sampling)
\layout Standard

Culling/Level of Detail Management
\layout Standard

Dithering
\layout Standard

Environment Mapping
\layout Standard

Fog
\layout Standard

Mipmapping
\layout Standard

Perspective Correct Texture Mapping
\layout Standard

Shading (Flat/Gourad)
\layout Standard

Specular Reflection/Shiny Surfaces (Metal Mario)
\layout Standard

Trilinear Mipmap Interpolation
\layout Standard

Z-Buffering
\layout Subsection

Interfacing System RAM
\layout Paragraph

The Rambus RDRAM memory used in the N64 has a 128-bit interface to the RCP,
 and is capable of 562.5 MB/s bandwidth.
 It has parity so it should generate a NMI when a parity error is detected
 (FIXME right?).
 The RAM is mapped at 0x00000000, and 64MB of address space is reserved
 for it.
 However, only 63MB of this address space can be used for physical memory,
 since the last 1MB is reserved for memory configuration registers.
\layout Subsubsection

Addressing
\layout Paragraph

The N64 console ships with 4MB of memory onboard, and a Rambus terminator
 called a 
\begin_inset Quotes eld
\end_inset 

Jumper Pak
\begin_inset Quotes erd
\end_inset 

 is installed in the memory expansion slot.
 A 4MB upgrade can be purchased and installed for a total of 8MB system
 memory.
 The following maps can be used depending on the amount of memory installed:
\layout Itemize

For 4MB memory, use 0x80000000-0x803FFFFF.
\layout Itemize

For 8MB memory, use 0x80000000-0x807FFFFF.
\layout Subsubsection

Memory Detection
\layout Paragraph

To check how much memory is installed, we consult the address 0x80000318.
 It corresponds to osMemSize from the SDK, and contains the size of memory
 (0x00400000 for 4MB or 0x00800000 for 8MB).
 The PIF-ROM code detects the size of memory and sets the value at that
 address before jumping to program code.
 If we wish to detect the size of memory ourselves instead of using the
 value the PIF-ROM gave us, we can use the following algorithm:
\layout Enumerate

Start at address (0x80400000 - 4) and a memory count of 4MB.
\layout Enumerate

Write a 32-bit word to the address, read it back, and compare it to the
 value written.
\layout Enumerate

If it is the same, add 0x100000 to the address and 1MB to the memory count.
\layout Enumerate

Repeat until the memory count is equal to the desired amount of memory.
 If we are only verifying the existence of an official memory expansion,
 stop when the memory count is equal to 8MB.
\layout Paragraph

Note that an attempt to access a non-existent physical memory address will
 result in an exception, so in order to prevent a CPU crash when performing
 memory detection, an appropriate general exception handler must be installed.
\layout Subsubsection

Access Strategy
\layout Paragraph

Since Rambus memory has a high latency but high bandwidth compared to SDRAM,
 observe the following strategy when using memory:
\layout Itemize

Try to batch memory accesses as much as possible to avoid access latency.
\layout Paragraph

You can accomplish this by reading or writing data as words or double words
 instead of as bytes, when possible.
\layout Subsubsection

Configuration
\layout Paragraph

The RDRAM controller configuration registers are 32-bit words mapped starting
 at 0x03F00000.
 Usually these registers do not need any configuration.
\newline 

\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Address
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Symbolic Name
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00000
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_CONFIG
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00004
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_DEVICE_ID
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00008
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_DELAY
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F0000C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_MODE
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00010
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_REF_INTERVAL
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00014
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_REF_ROW
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00018
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_RAS_INTERVAL
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F0001C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_MIN_INTERVAL
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00020
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_ADDR_SELECT
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00024
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RDRAM_DEVICE_MANUF
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA3F00028-0xA3FFFFFF
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Unknown/Unused
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Subsection

Programming the RI (RDRAM Interface)
\layout Paragraph

These registers are located in the RCP and are of 32-bit width.
 Usually they will not need to be modified.
 RI registers are mapped at 0x04700000.
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Address
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Symbolic Name
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700000
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_MODE
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700004
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_CONFIG
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700008
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_CURRENT_LOAD
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA470000C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_SELECT
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700010
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_REFRESH
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700014
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_LATENCY
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4700018
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_RERROR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

d0=>nack error, d1=>ack error
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA470001C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

RI_WERROR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Write to this register to clear RI_RERROR.
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Subsection

Programming the MI (MIPS Interface)
\layout Paragraph

This interface acts the 
\begin_inset Quotes eld
\end_inset 

glue
\begin_inset Quotes erd
\end_inset 

 between the CPU and the RCP.
 Its chief purpose is to determine the source of an interrupt.
 MI registers are mapped at 0x04300000.
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Address
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Symbolic Name
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4300000
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

MI_MODE
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4300004
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

MI_VERSION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA4300008
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

MI_INTR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0xA430000C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

MI_INTR_MASK
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Paragraph

FIXME describe various interrupt sources and masks.
\layout Subsection

Programming the VI (Video Interface)
\layout Paragraph

The VI is the frame buffer interface for the N64.
 It controls the resolution, color depth, and physical characteristics of
 the video display.
 On each screen redraw, it is responsible for reading the contents of the
 display from a given region in system memory (the frame buffer) and updating
 the image on the monitor.
 Resolutions from 256x224 to 640x480 can be used with 16 or 32-bit color
 depth.
 (PAL systems can use a 768x576 resolution FIXME?) What about MPAL?
\layout Standard

The VI's registers are mapped at 0x04400000.
\layout Subsection

AI (Audio Interface)
\layout Paragraph

This unit produces analog audio output from digital audio samples.
 It supports up to 48kHz samples and 4 to 16-bit sample resolution.
 It uses DMA to play samples directly from system memory.
 A sample can be queued for play while one is currently playing.
 Unfortunately there is no mixing of samples, so we must employ our own
 mixing routines.
 Mixing of multiple PCM streams, as well as sound manipulation such as ADPCM
 decompression, wavetable synthesis, and special effects (Voice, Pitch
 Shifting, Gain and Pan, Reverb and Chorus) are performed by
 application-specific RSP microcode.

\layout Subsection

PI (Peripheral Interface)
\layout Paragraph

This can be used to attach program cartridges to the system, or to attach
 development or other peripheral devices.
 It can be physically accessed both via the cartridge port on the top, or
 the 64DD port on the bottom.
 Accessing it is performed via DMA transfers to and from memory addresses
 in KUSEG.
 Does this have anything to do with SysAD?
\layout Standard

(the PI bus calls for embedded address decodes inside the devices...)
\layout Subsection

Programming the SI (Serial Interface)
\begin_inset LatexCommand \label{sub:Programming-the-SI}

\end_inset 


\layout Subsection

Programming the PIF (Peripheral InterFace)
\layout Paragraph

PIF-NUS (U6) has 2K of internal storage, divided between RAM and ROM.
 It is chiefly responsible for input device management.
 The 64-byte PIF-RAM can be used to examine the current state of input devices,
 and commands can be written there for the PIF to execute.
 In its ROM region, it stores a small bootstrap program (PIF-ROM) that the
 MIPS CPU's reset vector (0x1FC00000) is pointed to at power-on.
 The PIF-ROM is responsible for hardware security and will be discussed
 at length in that section.
\layout Standard

FIXME is there a PIF2 version w/different code?
\layout Paragraph

Don't confuse this with the PI which is also referred to as 
\begin_inset Quotes eld
\end_inset 

Peripheral Interface
\begin_inset Quotes erd
\end_inset 

.
\layout Paragraph

The PIF memory map is as follows:
\layout Itemize

0xBFC00000-0xBFC007BF: PIF-ROM
\layout Itemize

0xBFC007C0-0xBFC007FF: PIF-RAM
\layout Paragraph

To read or write to the PIF, we must execute a SI DMA (described in section
 
\begin_inset LatexCommand \ref{sub:Programming-the-SI}

\end_inset 

).
 (FIXME why is there an exception to this at boot time?)
\layout Subsection

Human Interface Devices
\layout Standard

controller, rumble pak, can we use keyboard/mouse?
\layout Subsection

Memory Devices
\layout Standard

cart eeprom/4xeep/flash/sram
\layout Standard

controller paks - paged (switching) vs linear.
 what does 
\begin_inset Quotes eld
\end_inset 

page count
\begin_inset Quotes erd
\end_inset 

 measure? 4X - 492 pages
\layout Standard

how to program a 4X linear memory pak?
\layout Standard

ds1/dx256 passthrough saversThe Z64 can only access the EEPROM and not the
 CIC chip (for they have the same data and clock lines, but a different
 chip select line).
\layout Standard

SRAM/FlashRAM is on Cartridge Domain 2 Address 2
\layout Subsection

Audio and Video Output
\layout Subsection

Security and Booting Considerations
\layout Subsubsection

Security hardware
\layout Paragraph

CIC chips, compare to SNES.
 Can we use a generic replacement to ship our own carts?
\layout Subsubsection

PIF ROM / Bootstrap
\layout Paragraph

The main task the PIF ROM performs is to ensure that the program code is
 authorized for execution.
 It performs a two-part verification procedure before jumping to program
 code.
 (FIXME verify this) The first step is to read two bytes from the security
 chip (CIC) located in the program cartridge.
 The first byte is used to calculate a checksum over the first 0x1000 bytes
 of the program.
 Then the boot code runs.
 
\layout Standard

The PIF ROM may serve other purposes (FIXME)
\layout Standard

There may be two versions of this.
 Consult ramrom.h
\layout Standard

PIF ROM ensures that the boot code has not been tampered with, according
 to some magic value from Nintendo.
 Boot code ensures that the program has not been tampered with, according
 to the checksum in the cartridge header.
\layout Subsubsection

Program header
\layout Paragraph

When the bootstrap code (described below) is executed, it eventually jumps
 to a start address to begin execution of the main program module.
 The bootstrap code compatible with the NUS-CIC-6103 and NUS-CIC-6106 lock-out
 chips (FIXME FIXME FIXME semantics) puts the code in a different location
 in memory, and thus the start address must be modified.
\layout Itemize

For NUS-CIC-6103 programs, add 0x100000 to the start address.
\layout Itemize

For NUS-CIC-6106 programs, add 0x200000 to the start address.
\layout Subsubsection

Bootstrap code
\layout Subsubsection

Program code
\layout Paragraph

Once the bootstrap code has transferred execution to our main program module,
 we are mostly in business.
 There is one remaining task to perform before we do anything else, and
 that is to OR the address 0xBFC007FC with 0x08.
 This address is located at the end of the PIF RAM, and it enables the soft-rese
t/NMI generation of the console's reset button.
 If this is not performed, the console will automatically reset in a few
 seconds.
 (FIXME WHY?) (Why don't we need to use SI DMA to do this write?)
\layout Paragraph

There is one snag we might encounter, and that is that the PIF ROM has only
 transferred the first 1MB of our program image to RAM.
 If the program code is larger than 1MB, then we must execute a PI DMA ourselves
 to transfer its remainder.
 This situation may manifest itself as seemingly random crashes on large
 projects, because the CPU will eventually jump to a program address that
 has not been loaded into RAM yet.
\layout Subsubsection

Boot emulators
\layout Standard

key - dont trash the structures that the PIF ROM sets up.
 (true?) This is why early 6105 boot emulators had problems determining
 whether a memory expansion pack was installed or not.
\layout Standard

- detect boot code of cart image
\layout Standard

- write proper cic value to $22
\layout Standard

- jump to game's boot code (or is it start address?)
\layout Standard

can we instead simply:
\layout Standard

- pi dma 1mb of program into ram
\layout Standard

- jump to start address
\layout Subsubsection

Soft resetting
\layout Subsubsection

Other notes
\layout Paragraph

FIXME There is a fixed memory location somewhere that can be used to preserve
 64-bytes of information across a NMI/soft reset but not a hard reset.
 (osAppNMIBuffer).
 Also, anything outside of the 1MB boot segment will remain untouched after
 a reboot.
\layout Section

Setting up GNU Binutils for N64
\layout Subsection

Introduction
\layout Paragraph

We will be developing for N64 using the free GNU toolchain and a Debian
 GNU/Linux host machine.
 The basic components of a toolchain are the utilities used to manipulate
 object files of machine language code, such as an assembler, a linker,
 a librarian/archiver, a profiler, and programs to copy to and from various
 object formats and to examine symbols within a particular object file.
 Later, we will add C and C++ compilers, standard C/C++ libraries, and a
 source-level debugger to complete the toolchain.
\layout Paragraph

GNU Binutils can be downloaded at:
\layout Itemize

http://sources.redhat.com/binutils/
\layout Paragraph

The most recent binutils release as of this writing is 2.15 (May 2004).
\layout Paragraph

Note that Debian provides a package named 'toolchain-source' that can expedite
 building a set of toolchain packages from scratch.
 This is typically an easier but less universal approach.
 Occasionally toolchain-source becomes unmaintained and out-of-date, so
 building from the upstream sources may be preferable in those cases.
\layout Subsection

Configuring and Building Binutils
\layout Paragraph

Once we have downloaded the file (in bzip2 format), execute the following
 commands to unpack it and change into its directory:
\layout Itemize

$ tar jxf binutils-2.15.tar.bz2
\layout Itemize

$ cd binutils-2.15
\layout Paragraph

Next, we will configure the package for building.
 First, we need to define a few standard options for building the toolchain.
\layout Itemize

Build system
\newline 
The type of system that the package is being built on.
\layout Itemize

Host system
\newline 
The type of system that the built package will run on.
\layout Itemize

Target system
\newline 
The type of system that the built package will produce object code for.
\layout Paragraph

Usually, and especially in this case, the Build and Host systems will be
 the same.
 We are building the package on an i386 host to execute on an i386 host,
 and those will be automatically detected by the configure process.
 However, the target system is our N64.
 
\layout Paragraph

The toolchain configuration options expect a canonical system name.
 We can use the included 'config.guess' script to find the canonical system
 name of the host, but since we cannot run this script on the target, we
 must reasonably guess a canonical system name for the target.
\layout Paragraph

A canonical system name is comprised of the following components, separated
 by dashes:
\layout Enumerate

Hardware architecture (including endianness)
\layout Enumerate

System vendor (or 'unknown', or nothing)
\layout Enumerate

Operating system or object file format
\layout Paragraph

For our N64, the hardware architecture is 'mips' (little endian would be
 'mipsel').
 For discussion of 64-bit issues, see 
\begin_inset LatexCommand \ref{sub:64-Bit-Issues}

\end_inset 

.
 We don't really need to worry about them right now except that our toolchain
 should be configured as 'mips64' and not 'mips'.
\layout Paragraph

The system vendor should be 'unknown' since the GNU toolchain has no pre-existin
g support for it.
 However, it turns out that we need the system vendor to be 'linux' in order
 to (coupled with 'mips64' arch) obtain a toolchain capable of using the
 desired 'n32' ABI (see 
\begin_inset LatexCommand \ref{sub:64-Bit-Issues}

\end_inset 

).
\layout Paragraph

rem Since we are not building object code to run under an operating system,
 we could define an object file format instead.
 We will use ELF (Executable and Linkable Format), which is 'elf' in the
 canonical name.
 ELF is a suitably flexible object format in general, but using ELF means
 that our toolchain will also be compatible with the official SDK libraries,
 which are in ELF format.
 A licensed developer might wish to use a toolchain built here to build
 a program with code from the official SDK.
\layout Paragraph

Putting the pieces together, we have:
\layout Itemize

mips64-linux
\layout Itemize

or
\layout Itemize

mips-unknown-linux-elf
\layout Paragraph

Our configure command is thus:
\layout Itemize

./configure --prefix=/usr/local/n64 --program-prefix=n64- --target=mips64-linux
\layout Paragraph

We define a program-prefix for the programs in our N64 toolchain, so that
 our binaries do not have name conflicts with any other toolchain already
 on the system.
\layout Paragraph

After Binutils is configured, simply issue 'make' to complete the build.
 If there are no errors, issue 'make install', and the fundamental pieces
 of our toolchain will have been installed in /usr/local/n64.
\layout Subsection

Binutils Components
\layout Itemize

n64-ar - Archiver, for combining object files into libraries
\layout Itemize

n64-as - Assembler, to encode assembly source files into machine instructions
\layout Itemize

n64-ld - Linker, to combine separate object files into a program and resolve
 symbol references between objects
\layout Itemize

n64-nm - Lists symbols and interfaces in object files
\layout Itemize

n64-objcopy - Translates between different object file formats
\layout Itemize

n64-objdump - Display information about an object file, including its disassembl
y
\layout Itemize

n64-ranlib - Create symbol index in a library
\layout Itemize

n64-size - Display size of object file sections
\layout Itemize

n64-strings - Search object for NUL-terminated ASCII strings
\layout Itemize

n64-strip - Remove profiling information, debugging information, and/or
 symbols from an object
\layout Paragraph

Our exposure to these tools will primarily be limited to ar, as, ld, objdump,
 and strip.
 However, all of these tools are useful in various circumstances, since
 they are nearly the only resources we have to easily manipulate binary
 object files.
\layout Subsection

Using Binutils
\layout Paragraph

You can add the N64 toolchain to your executable search path:
\layout Itemize

$ PATH=$PATH:/usr/local/n64/bin
\layout Paragraph

Then, for example to invoke the assembler, you can just type 'n64-as' instead
 of '/usr/local/n64/bin/n64-as'.
\layout Paragraph

Assemble the following test program, passing -mips3 to the assembler.
 This will verify that the assembler works as expected:
\layout Standard

FIXME
\layout Paragraph

For developing your own programs in assembly language, see the 
\begin_inset Quotes eld
\end_inset 

The MIPS64 Architecture For Programmers
\begin_inset Quotes erd
\end_inset 

 volumes I and II.
\layout Section

Bootstrapping the Development Environment
\layout Subsection

Building a N64 Program Image
\layout Subsubsection

Header
\layout Subsubsection

Boot Code
\layout Subsubsection

Checksum
\layout Standard

ld script
\layout Section

Using and Extending a Hardware Simulator (vmips)
\layout Standard

- useful for fast prototyping
\layout Standard

cheaper than dedicated simulation hw (INDY device or PSY-Q SCSI thing
\layout Standard

requires a fast CPU to simulate the target in realtime
\layout Standard

must emulate peripherals in software
\layout Standard

require boot rom from N64
\layout Section

Building A C/C++ Toolchain
\layout Subsection

64-Bit Issues
\begin_inset LatexCommand \label{sub:64-Bit-Issues}

\end_inset 


\layout Paragraph

The N64 CPU is capable of using its general purpose registers in 64-bit
 mode by setting a CPU flag.
 However, just doing this does not provide any advantage to software, since
 the compiler may not be emitting instructions that utilize 64-bit registers.
 The question is, under what circumstances do we wish to actually utilize
 64-bit code?
\layout Paragraph

64-bit code does not necessarily run faster than 32-bit code.
 64-bit register loads take more instructions, increasing the storage size
 of the executable code and decreasing cache efficiency.
 64-bit constants also increase the size of the executable code.
 So we want to only emit 64-bit code when it makes sense for our application.
\layout Paragraph

First of all, it would be nonsense to use 64-bit pointers in the N64, since
 its entire memory map, including hardware, fits in a 32-bit address space.
\layout Paragraph

Since the GNU C compiler fixes the default size of the pointer to be equal
 to the size of the long, it would be more convenient to have 32-bit longs,
 because then we would not have to explicitly declare pointers to be 32-bit.
\layout Paragraph

The base of existing open source software typically assumes that a long
 is 32 bits, since that's what most machines today use.
 So this choice would also eliminate issues of porting third-party code
 to the N64.
\layout Paragraph

We thus have several advantages to choosing a ILP32 (integer, long, pointer
 = 32-bit) target over a LP64 (long, pointer = 64-bit) target.
 Furthermore, we can still utilize 64-bit integers in any special cases
 by using the 'long long' type and passing -mips3 to the compiler (enabling
 MIPS III ISA, required for instructions that utilize 64-bit registers).
\layout Paragraph

The next challenge will be to choose an ABI (Application Binary Interface).
 The ABI essentially defines the size of C data types as well as establishing
 a convention for function calls with respect to what arguments are passed
 in registers, what is passed on the stack and where on the stack it is
 located, and where to find the function's return value.
 An ABI is what allows us to link object modules together and expect them
 to work.
 We will also need to respect the ABI when mixing C modules with pure assembly
 modules (usually C modules with inline assembly are more convenient).
\layout Paragraph

MIPS defines four ABIs - 'o32', 'n32', 'o64', and 'n64', where the 'o' means
 'old' and the 'n' means 'native', and where the default 32-bit ABI is 'o32'
 and the default 64-bit ABI is 'n64'.
 (The name is a coincidence.) The 'o32' ABI is the first MIPS ABI.
 It is ILP32 and only MIPS I/II instructions are allowed.
 It also allows only 16 floating point registers to be used, hampering modern
 FP coprocessors.
 The 'o64' ABI is obsolete and irrelevant for this discussion.
 The 'n64' ABI was the 64-bit ABI that replaced 'o32'.
 It is LP64, allows 32 FP registers to be used, and allows MIPS III/IV instructi
ons.
 However, this ABI has all the disadvantages of 64-bit architectures noted
 above.
 As a compromise, the 'n32' ABI was developed.
 Like the 'n64' ABI, it allows 32 FP registers as well as MIPS III/IV instructio
ns.
 However, it is ILP32, which turns out to be much more efficient on an embedded
 system like the N64.
\layout Paragraph

So we will want to build our application code with a 'n32' ABI, which is
 done by specifying -mabi=n32 to the GNU compiler.
 This implies the -mips3 option.
 (The GNU compiler's default is to compile for MIPS I and the 'o32' [-mabi=32]
 ABI.) If the toolchain is configured as noted below, the 'n32' ABI will
 be the default.
\layout Paragraph

The proprietary Nintendo ELF libraries are built for MIPS II with the 'o32'
 ABI.
 If you want to link your code with the Nintendo libraries, you will need
 to compile it with the -mips2 option (which implies -mabi=32, for 'o32').
\layout Paragraph

For a GNU configure tuple, the 'mips' target implies a default 'o32' ABI.
 The problem with configuring like this is that 'n32' isn't then even available
 as a target ABI.
 Current binutils (2.15) requires a mips64-linux target in order for the
 'n32' ABI to be enabled, and in which case, it will become the default.
 So we will use 'mips64' as the architecture and 'linux' as the system vendor,
 even though neither particularly makes sense in this scenario.
\layout Paragraph

Remember that if you are using functions written in assembly language, you
 must obey the ABI that your application is using.
 It would also be a good idea to assemble with the appropriate -mips[1-4]
 and -mabi=? options, so that the assembler can verify that you haven't
 accidentally used an instruction that is invalid for the ABI and ISA that
 you are using.
 You can find the information on the 'n32' ABI in the following document:
 
\begin_inset Quotes eld
\end_inset 

MIPSpro N32 ABI Handbook
\begin_inset Quotes erd
\end_inset 

 (SGI document number: 007-2816-005).
\layout Paragraph

Note: Instead of using -mips3 when compiling, you can use -march=vr4300.
 This option implies -mips3, additionally enables any tuning for that specific
 CPU, and doesn't work around errata not present in that CPU like a generic
 -mips[1-4] option would.
 (A generic option must support any CPU that implements that ISA level,
 no matter what bugs it has, so that option will implement a union of all
 workarounds for CPUs implementing that ISA level.) We can do this on the
 N64 because we know exactly what CPU is used on the target, and that our
 code will never need to run on any other CPU.
\layout Subsection

Building the GNU C Compiler Without A Target OS
\layout Paragraph

We will be building what is known as a 'bootstrap' C compiler.
 It does not have support for threads or shared libraries.
 However, it does not require a C library, which at this point is the situation
 we are in.
 We will also wait until later to build the C++ compiler, since building
 it requires a working C library.
 Once the bootstrap compiler is built, we will use it to build a C library
 that either requires (glibc) or does not require (newlib) an operating
 system.
 Once that C library is built, we will then build a C++ compiler, and also
 rebuild the C compiler, with thread and shared library support if the target
 operating system supports it.
 The C++ compiler and rebuilding of the C compiler can be skipped if there
 is no necessity for those features on the target (e.g., if the bootstrap
 compiler is sufficient to produce the application code for the target).
\layout Standard

./configure --prefix=/afs/icequake.net/dist/arch/i386_linux24/toolchain --program-
prefix=n64- --target=mips64-linux --disable-threads --disable-nls --disable-shar
ed --enable-languages=c --without-headers --with-newlib 
\layout Section

Building A Reusable Library of Functionality
\layout Standard

host - general functions + includes with constants + host specific functions
\layout Standard

target - general functions + includes with constants + target specific functions
 (communications slave, inline asm, etc)
\layout Section

Performance Evaluation and Benchmarking
\layout Subsection

Bottlenecks
\layout Subsubsection

Video
\layout Paragraph

While the N64's graphics hardware is reasonably fast, it is still not very
 competitive even with the Sony PlayStation which was released nearly two
 years ahead of it.
 The two video bottlenecks are:
\layout Itemize

Triangle throughput
\layout Paragraph

The N64 has a claimed 150,000 fully lit and transformed polygons per second
 throughput.
 While this sounds like a lot, it really isn't, especially in complex scenes.
 At 30fps, that is only 5,000 polygons per frame.
 Using flat or gourad shading can help this throughput.
 We don't know if this number includes texture mapping, so we will test
 this.
 Note that if the RSP is being used for audio processing, polygon throughput
 will suffer; not only will the RSP be dividing its computation time between
 two tasks, but the RSP microcode must also be reloaded every time it changes
 duties.
\layout Itemize

Texture memory
\layout Paragraph

The RDP has 4KB of texture memory, which is precisely enough for one 32x32
 32-bit RGBA texture.
 We can make more efficient use of this memory by using smaller textures
 or scaling down the color depth, but image quality will suffer.
 Unfortunately, we cannot avoid thrashing on such a small amount of memory,
 so we must be creative with our texture usage.
\layout Subsubsection

Audio Hardware
\layout Paragraph

The N64 AI (Audio Interface) is only a very simplistic audio processor,
 compared to the competing Sega Saturn and Sony PlayStation.
 It has a set of registers which, at any time, can have at most one sample
 queued while playing one sample from memory.
 Samples can be 4 to 16-bit, up to 48KHz, raw or ADPCM format.
 Any mixing, synthesis, or effects processing must be done by the CPU or
 RSP in real-time, at an incremental performance cost for each channel or
 effect in use.
\layout Subsubsection

Unified Memory
\layout Paragraph

The N64's unified memory architecture, while convenient to program, presents
 an additional performance issue: peripherals must contend for memory access.
 When only using one peripheral at a time, this should not be a problem
 at all.
 But consider this scenario: we are playing a sound buffer on the AI, and
 a PI DMA is performed to transfer more sound or model data into memory,
 while the RSP writes a RDP command list to a FIFO buffer in memory, and
 the RDP reads from that buffer and writes to the back framebuffer...
 and on top of that, the VI must read the entire contents of the the front
 framebuffer up to 60 times per second in order to refresh the display!
\layout Paragraph

This sounds like a contrived scenario, but it really is not; this is what
 is going on inside the N64 at all times when a typical game program is
 running.
 The problem is that we could spend years trying to optimize each line of
 code to ensure that hardware does not waste time waiting on memory access,
 but that would most likely yield only a marginal improvement compared to
 the amount of time spent on execution analysis trials.
 Instead, we will try to single out some worst-case memory access patterns
 through benchmarking, and optimize out those cases in library code so that
 all applications will benefit.
\layout Subsection

Benchmark Design
\layout Section

Porting RedBoot/eCos
\layout Standard

RedBoot can be used as a general purpose debug loader, or specifically as
 a Linux bootloader.
\layout Section

Porting Linux
\layout Subsection

The kernel
\layout Subsubsection

ucLinux
\layout Paragraph

Kernel messages -> screen, or debug stub (gameshark, cd64, z64, etc)
\layout Subsubsection

framebuffer
\layout Subsubsection

startup code
\layout Subsection

Userland
\layout Subsubsection

cramfs
\layout Subsubsection

busybox (as init replacement)
\layout Subsubsection

newlib
\layout Subsubsection

dynamically linked busybox
\layout Subsection

Drivers
\layout Subsubsection

Input
\layout Paragraph

We will support the use of a joystick and/or a hacked mouse.
 Explore keyboard input.
 Force feedback (rumble).
\layout Subsubsection

DirectFB OpenGL
\layout Subsubsection

ALSA Audio
\layout Subsubsection

Cartridge/peripheral interface
\layout Paragraph

On devices with PI registers, we should be able to access the Zip disk or
 CD filesystems transparently, and to use the communications port of peripherals.
 We should have an interface to dump the cart and to write to the PI safely.
\layout Subsubsection

Memory technology devices (cart memory, memory packs)
\layout Subsubsection

Serial interface
\layout Paragraph

Can the controller interface be used as a general serial interface (so we
 can e.g.
 get a terminal or run PPP over an Adaptoid?) We need to find out how to
 get SI interrupts.
\layout Subsubsection

Power management
\layout Paragraph

Is R4300's low power mode supported? Can we enable it when the machine has
 been idle?
\layout Subsection

Userspace code examples
\layout Subsubsection

Universal APIs (OpenGL, ALSA)
\layout Subsubsection

System-specific APIs (cart dumping)
\layout Subsection

Preparing a Linux-N64 program for market
\layout Section

Porting KallistiOS
\layout Section

Complete Hardware Reference 
\layout Section

Peripheral Hardware Reference 
\layout Subsection

UFO/Success CD64
\layout Subsubsection

CD64 Hardware and Operation
\layout Subsubsection

Upgrading and Modifying the CD64 Hardware
\layout Subsubsection

Interfacing the CD64 from a N64 program
\layout Standard

Example of writing a replacement CD64 BIOS.
\layout Subsubsection

CD64 PI Register Map
\layout Subsubsection

Communicating with the CD64 BIOS and Ghemor from a PC
\layout Subsection

Mr.
 Backup Z64
\layout Subsubsection

Z64 Hardware and Operation
\layout Standard

HW1/HW2/HW3 differences
\layout Subsubsection

Upgrading and Modifying the Z64 Hardware
\layout Standard

RAM upgrade (512KB -> 1MB)
\layout Standard

HD/Zip250/Orb upgrade
\layout Standard

Connecting IRQ/DMA lines
\layout Standard

NIC/parallel port/commslink/VGA addons
\layout Standard

keyboard connector
\layout Subsubsection

Interfacing the Z64 from a N64 program
\layout Standard

Example of writing a replacement Z64 BIOS.
\layout Subsubsection

Z64 PI Register Map
\layout Subsubsection

Modifying the Z64 Operating System
\layout Subsubsection

Communicating with the Z64 from a PC
\layout Subsection

Bung Doctor V64
\layout Subsubsection

Doctor V64 Hardware and Operation
\layout Subsubsection

Upgrading and Modifying the Doctor V64 Hardware
\layout Subsubsection

Modifying the Doctor V64 Operating System
\layout Subsubsection

Communicating with the Doctor V64 from a PC
\layout Subsection

Bung Doctor V64jr
\layout Subsubsection

Doctor V64jr Hardware and Operation
\layout Subsubsection

Upgrading and Modifying the Doctor V64jr Hardware
\layout Subsubsection

Interfacing the Doctor V64jr from a N64 program
\layout Subsubsection

Communicating with the Doctor V64jr from a PC
\layout Subsection

Valery's PV-Backup
\layout Subsection

Ultra64Pro RAM Card
\layout Standard

8-64MB SDRAM/EDO Battery backup
\layout Standard

PC connection (ECP or USB)
\layout Standard

R/W registers mapped to N64 PI to change mode and N64<->PC comms
\layout Standard

built in save emulation for SRAM, 4K/16K EEP <->controller pak file (compress
 SRAM to fit normal pak) and flashram <->4X controller pak
\layout Standard

BIOS with save management and configuration runs if no file loaded CIC passthrou
gh or emulation
\layout Subsection

Wildcard 64
\layout Subsection

Datel Game Shark Pro
\layout Subsubsection

Loading and Booting N64 Code
\layout Subsubsection

Communicating with the Game Shark from a PC
\layout Subsubsection

Communicating with the PC from a N64 program
\layout Subsection

Wishtech Adaptoid
\layout Subsection

Generic SI<->RS232 adapter (PIC?)
\layout Subsection

Tristar 64
\layout Subsection

GB Hunter/Game Booster 2in1
\layout Subsection

64DD Disk Drive (
\begin_inset Quotes eld
\end_inset 

Leo
\begin_inset Quotes erd
\end_inset 

)
\layout Subsection

PSY-Q Development Board and Suite
\layout Subsection

Indy Emulator (Official)
\layout Subsection

N64 Country Adapters (Passport, etc)
\layout Standard

Do they have a program/bootemu or are they only a physical adapter? Semantics
 of booting PAL vs NTSC (security chip), PAL-fixing, cart interchangeability
\the_end
